library(rland)
library(rlang)
is_empty(kI)
help(append)
keepIdx <- append(keepIdx,kI)
keepIdx
idx
keepIdx <- list()
#probably a better way to do this, but I need the index
for (idx in 1:dim(metaData)[1]) {
kI <- which(metaData$nameWithCSV[idx] == mData$variable)
keepIdx <- append(keepIdx,kI)
rm(kI)
}
keepIdx
keepIdx <- data.frame()
#probably a better way to do this, but I need the index
for (idx in 1:dim(metaData)[1]) {
kI <- which(metaData$nameWithCSV[idx] == mData$variable)
keepIdx <- append(keepIdx,kI)
rm(kI)
}
View(keepIdx)
help(issorted)
??issorted
help(is.unsorted)
is.unsorted(keepIdx)
is.unsorted(keepIdx$value)
is.sorted(keepIdx$value)
#only keep the rows in metaData with actual data
useIdx <- keepIdx$value
metaData_keep <- metaData[useIdx,]
#only keep the rows in metaData with actual data
useIdx <- keepIdx$value
#only keep the rows in metaData with actual data
useIdx <- keepIdx
metaData_keep <- metaData[useIdx,]
typeof(list)
typeof(useIdx)
#only keep the rows in metaData with actual data
useIdx <- as.numeric(keepIdx)
metaData_keep <- metaData[useIdx,]
#check again that mData and metaData match
for (idx in 1:dim(mData)[1]) {
kI <- which(mData$variable[idx] == metaData$nameWithCSV)
keepIdx <- append(keepIdx,kI)
rm(kI)
}
rm(list=ls.str())
library(vegan)
library(ggplot2)
# library(ggdendro)
library(flashClust)
library(xlsx) #will require 64 bit java, if issues, check that first
library(data.table) #use to move bw lists/data.frames
library(rlang)
options(stringsAsFactors = FALSE)
#setup file names ahead of time, will be used to save and export data
NameOfFile = 'DOMsynthesis_workingNMS.2023.10.27.Rimage'
#WriteCSVname = 'someDataFile.csv'
#metadata - working in one folder for now
#wDir = "C:/Users/klongnecker/Documents/GitHub/DOMsynthesis/_data_from/"
fName = 'Summary_Andrew_crosstab_wihout_iso_na.csv'
fName_metadata <- 'DOM_Synthesis_Data.Agg_WA_Meta.csv'
# #read in the metadata, but shut down the errors
# suppressWarnings({
# mData <- read_excel(fName)
# })
mData <- read.csv(fName,header=TRUE)
metaData <- read.csv(fName_metadata,header = TRUE)
#sadly, these two files have different number of rows. I suspect there are some samples with no metaData. So, first find the places that do not match and then remove the rows with no metaData as they will not be helpful for my purposes; sadly this involves more steps
#mData$variable #use this to match (ends with CSV)
#metaData$Sample #nothing after sample name
#metaData$coreMSname #nothing after sample name
#easiest is probably to add csv to each metaData row
for (idx in 1:dim(metaData)[1]) {
one <- metaData$Sample[idx]
metaData$nameWithCSV[idx] <- paste0(one,".csv")
rm(one)
}
rm(idx)
keepIdx <- data.frame()
#probably a better way to do this, but I need the index
for (idx in 1:dim(metaData)[1]) {
kI <- which(metaData$nameWithCSV[idx] == mData$variable)
keepIdx <- append(keepIdx,kI)
rm(kI)
}
rm(idx)
#hmm...seems we have metadata with no sample (not sure what's going on) (definitely have samples with no metadata...)
#only keep the rows in metaData with actual data
useIdx <- as.numeric(keepIdx)
metaData_keep <- metaData[useIdx,]
rm(keepIdx)
#check again that mData and metaData match
for (idx in 1:dim(mData)[1]) {
kI <- which(mData$variable[idx] == metaData$nameWithCSV)
keepIdx <- append(keepIdx,kI)
rm(kI)
}
rm(keepIdx,useIdx)
#check again that mData and metaData match
keepIdx <- data.frame()
# #read in the metadata, but shut down the errors
# suppressWarnings({
# mData <- read_excel(fName)
# })
mData <- read.csv(fName,header=TRUE)
metaData <- read.csv(fName_metadata,header = TRUE)
#easiest is probably to add csv to each metaData row
for (idx in 1:dim(metaData)[1]) {
one <- metaData$Sample[idx]
metaData$nameWithCSV[idx] <- paste0(one,".csv")
rm(one)
}
rm(idx)
keepIdx <- data.frame()
#probably a better way to do this, but I need the index
for (idx in 1:dim(metaData)[1]) {
kI <- which(metaData$nameWithCSV[idx] == mData$variable)
keepIdx <- append(keepIdx,kI)
rm(kI)
}
rm(idx)
#only keep the rows in metaData with actual data
useIdx <- as.numeric(keepIdx)
metaData_keep <- metaData[useIdx,]
rm(keepIdx,useIdx,metaData)
#check again that mData and metaData match
keepIdx <- data.frame()
for (idx in 1:dim(mData)[1]) {
kI <- which(mData$variable[idx] == metaData_keep$nameWithCSV)
keepIdx <- append(keepIdx,kI)
rm(kI)
}
#only keep the rows in mData with matching metaData data
useIdx <- as.numeric(keepIdx)
mData_keep <- mData_keep[useIdx,]
rm(keepIdx,useIdx,mData)
rm(idx)
#metadata - working in one folder for now
#wDir = "C:/Users/klongnecker/Documents/GitHub/DOMsynthesis/_data_from/"
fName = 'Summary_Andrew_crosstab_wihout_iso_na.csv'
fName_metadata <- 'DOM_Synthesis_Data.Agg_WA_Meta.csv'
# #read in the metadata, but shut down the errors
# suppressWarnings({
# mData <- read_excel(fName)
# })
mData <- read.csv(fName,header=TRUE)
metaData <- read.csv(fName_metadata,header = TRUE)
#sadly, these two files have different number of rows. I suspect there are some samples with no metaData. So, first find the places that do not match and then remove the rows with no metaData as they will not be helpful for my purposes; sadly this involves more steps
#mData$variable #use this to match (ends with CSV)
#metaData$Sample #nothing after sample name
#metaData$coreMSname #nothing after sample name
#easiest is probably to add csv to each metaData row
for (idx in 1:dim(metaData)[1]) {
one <- metaData$Sample[idx]
metaData$nameWithCSV[idx] <- paste0(one,".csv")
rm(one)
}
rm(idx)
keepIdx <- data.frame()
#probably a better way to do this, but I need the index
for (idx in 1:dim(metaData)[1]) {
kI <- which(metaData$nameWithCSV[idx] == mData$variable)
keepIdx <- append(keepIdx,kI)
rm(kI)
}
rm(idx)
#hmm...seems we have metadata with no sample (not sure what's going on) (definitely have samples with no metadata...)
#only keep the rows in metaData with actual data
useIdx <- as.numeric(keepIdx)
metaData_keep <- metaData[useIdx,]
rm(keepIdx,useIdx,metaData)
#check again that mData and metaData match
keepIdx <- data.frame()
for (idx in 1:dim(mData)[1]) {
kI <- which(mData$variable[idx] == metaData_keep$nameWithCSV)
keepIdx <- append(keepIdx,kI)
rm(kI)
}
rm(idx)
#only keep the rows in mData with matching metaData data
useIdx <- as.numeric(keepIdx)
mData_keep <- mData[useIdx,]
rm(keepIdx,useIdx,mData)
#metadata - working in one folder for now
#wDir = "C:/Users/klongnecker/Documents/GitHub/DOMsynthesis/_data_from/"
fName = 'Summary_Andrew_crosstab_wihout_iso_na.csv'
fName_metadata <- 'DOM_Synthesis_Data.Agg_WA_Meta.csv'
# #read in the metadata, but shut down the errors
# suppressWarnings({
# mData <- read_excel(fName)
# })
mData <- read.csv(fName,header=TRUE)
metaData <- read.csv(fName_metadata,header = TRUE)
#sadly, these two files have different number of rows. I suspect there are some samples with no metaData. So, first find the places that do not match and then remove the rows with no metaData as they will not be helpful for my purposes; sadly this involves more steps
#mData$variable #use this to match (ends with CSV)
#metaData$Sample #nothing after sample name
#metaData$coreMSname #nothing after sample name
#easiest is probably to add csv to each metaData row
for (idx in 1:dim(metaData)[1]) {
one <- metaData$Sample[idx]
metaData$nameWithCSV[idx] <- paste0(one,".csv")
rm(one)
}
rm(idx)
keepIdx <- data.frame()
#probably a better way to do this, but I need the index
for (idx in 1:dim(metaData)[1]) {
kI <- which(metaData$nameWithCSV[idx] == mData$variable)
keepIdx <- append(keepIdx,kI)
rm(kI)
}
rm(idx)
#hmm...seems we have metadata with no sample (not sure what's going on) (definitely have samples with no metadata...)
#only keep the rows in metaData with actual data
useIdx <- as.numeric(keepIdx)
metaData <- metaData[useIdx,]
rm(keepIdx,useIdx)
#check again that mData and metaData match
keepIdx <- data.frame()
for (idx in 1:dim(mData)[1]) {
kI <- which(mData$variable[idx] == metaData_keep$nameWithCSV)
keepIdx <- append(keepIdx,kI)
rm(kI)
}
rm(idx)
#only keep the rows in mData with matching metaData data
useIdx <- as.numeric(keepIdx)
mData <- mData[useIdx,]
rm(keepIdx,useIdx)
library(vegan)
library(ggplot2)
# library(ggdendro)
library(flashClust)
library(xlsx) #will require 64 bit java, if issues, check that first
library(data.table) #use to move bw lists/data.frames
library(rlang)
options(stringsAsFactors = FALSE)
rm(list=ls.str())
#setup file names ahead of time, will be used to save and export data
NameOfFile = 'DOMsynthesis_workingNMS.2023.10.27.Rimage'
#WriteCSVname = 'someDataFile.csv'
#metadata - working in one folder for now
#wDir = "C:/Users/klongnecker/Documents/GitHub/DOMsynthesis/_data_from/"
fName = 'Summary_Andrew_crosstab_wihout_iso_na.csv'
fName_metadata <- 'DOM_Synthesis_Data.Agg_WA_Meta.csv'
# #read in the metadata, but shut down the errors
# suppressWarnings({
# mData <- read_excel(fName)
# })
mData <- read.csv(fName,header=TRUE)
metaData <- read.csv(fName_metadata,header = TRUE)
#sadly, these two files have different number of rows. I suspect there are some samples with no metaData. So, first find the places that do not match and then remove the rows with no metaData as they will not be helpful for my purposes; sadly this involves more steps
#mData$variable #use this to match (ends with CSV)
#metaData$Sample #nothing after sample name
#metaData$coreMSname #nothing after sample name
#easiest is probably to add csv to each metaData row
for (idx in 1:dim(metaData)[1]) {
one <- metaData$Sample[idx]
metaData$nameWithCSV[idx] <- paste0(one,".csv")
rm(one)
}
rm(idx)
keepIdx <- data.frame()
#probably a better way to do this, but I need the index
for (idx in 1:dim(metaData)[1]) {
kI <- which(metaData$nameWithCSV[idx] == mData$variable)
keepIdx <- append(keepIdx,kI)
rm(kI)
}
rm(idx)
#hmm...seems we have metadata with no sample (not sure what's going on) (definitely have samples with no metadata...)
#only keep the rows in metaData with actual data
useIdx <- as.numeric(keepIdx)
metaData <- metaData[useIdx,]
rm(keepIdx,useIdx)
#check again that mData and metaData match
keepIdx <- data.frame()
for (idx in 1:dim(mData)[1]) {
kI <- which(mData$variable[idx] == metaData_keep$nameWithCSV)
keepIdx <- append(keepIdx,kI)
rm(kI)
}
#metadata - working in one folder for now
#wDir = "C:/Users/klongnecker/Documents/GitHub/DOMsynthesis/_data_from/"
fName = 'Summary_Andrew_crosstab_wihout_iso_na.csv'
fName_metadata <- 'DOM_Synthesis_Data.Agg_WA_Meta.csv'
# #read in the metadata, but shut down the errors
# suppressWarnings({
# mData <- read_excel(fName)
# })
mData <- read.csv(fName,header=TRUE)
metaData <- read.csv(fName_metadata,header = TRUE)
#sadly, these two files have different number of rows. I suspect there are some samples with no metaData. So, first find the places that do not match and then remove the rows with no metaData as they will not be helpful for my purposes; sadly this involves more steps
#mData$variable #use this to match (ends with CSV)
#metaData$Sample #nothing after sample name
#metaData$coreMSname #nothing after sample name
#easiest is probably to add csv to each metaData row
for (idx in 1:dim(metaData)[1]) {
one <- metaData$Sample[idx]
metaData$nameWithCSV[idx] <- paste0(one,".csv")
rm(one)
}
rm(idx)
keepIdx <- data.frame()
#probably a better way to do this, but I need the index
for (idx in 1:dim(metaData)[1]) {
kI <- which(metaData$nameWithCSV[idx] == mData$variable)
keepIdx <- append(keepIdx,kI)
rm(kI)
}
rm(idx)
#hmm...seems we have metadata with no sample (not sure what's going on) (definitely have samples with no metadata...)
#only keep the rows in metaData with actual data
useIdx <- as.numeric(keepIdx)
metaData <- metaData[useIdx,]
rm(keepIdx,useIdx)
#check again that mData and metaData match
keepIdx <- data.frame()
for (idx in 1:dim(mData)[1]) {
kI <- which(mData$variable[idx] == metaData$nameWithCSV)
keepIdx <- append(keepIdx,kI)
rm(kI)
}
rm(idx)
#only keep the rows in mData with matching metaData data
useIdx <- as.numeric(keepIdx)
mData <- mData[useIdx,]
rm(keepIdx,useIdx)
library(vegan)
library(ggplot2)
# library(ggdendro)
library(flashClust)
library(xlsx) #will require 64 bit java, if issues, check that first
library(data.table) #use to move bw lists/data.frames
library(rlang)
options(stringsAsFactors = FALSE)
rm(list=ls.str())
#setup file names ahead of time, will be used to save and export data
NameOfFile = 'DOMsynthesis_workingNMS.2023.10.27.Rimage'
#WriteCSVname = 'someDataFile.csv'
#metadata - working in one folder for now
#wDir = "C:/Users/klongnecker/Documents/GitHub/DOMsynthesis/_data_from/"
fName = 'Summary_Andrew_crosstab_wihout_iso_na.csv'
fName_metadata <- 'DOM_Synthesis_Data.Agg_WA_Meta.csv'
# #read in the metadata, but shut down the errors
# suppressWarnings({
# mData <- read_excel(fName)
# })
mData <- read.csv(fName,header=TRUE)
metaData <- read.csv(fName_metadata,header = TRUE)
rm(fName*)
help(rm)
rm(fName,fName_metadata)
#easiest is probably to add csv to each metaData row
for (idx in 1:dim(metaData)[1]) {
one <- metaData$Sample[idx]
metaData$nameWithCSV[idx] <- paste0(one,".csv")
rm(one)
}
keepIdx <- data.frame()
#probably a better way to do this, but I need the index
for (idx in 1:dim(metaData)[1]) {
kI <- which(metaData$nameWithCSV[idx] == mData$variable)
keepIdx <- append(keepIdx,kI)
rm(kI)
}
#only keep the rows in metaData with actual data
useIdx <- as.numeric(keepIdx)
metaData <- metaData[useIdx,]
mData <- mData[useIdx,]
rm(keepIdx,useIdx)
#check again that mData and metaData match
keepIdx <- data.frame()
for (idx in 1:dim(mData)[1]) {
kI <- which(mData$variable[idx] == metaData$nameWithCSV)
keepIdx <- append(keepIdx,kI)
rm(kI)
}
#only keep the rows in mData with matching metaData data
useIdx <- as.numeric(keepIdx)
mData <- mData[useIdx,]
metaData <- metaData[useIdx,1]
rm(keepIdx,useIdx)
#metadata - working in one folder for now
#wDir = "C:/Users/klongnecker/Documents/GitHub/DOMsynthesis/_data_from/"
fName = 'Summary_Andrew_crosstab_wihout_iso_na.csv'
fName_metadata <- 'DOM_Synthesis_Data.Agg_WA_Meta.csv'
# #read in the metadata, but shut down the errors
# suppressWarnings({
# mData <- read_excel(fName)
# })
mData <- read.csv(fName,header=TRUE)
metaData <- read.csv(fName_metadata,header = TRUE)
rm(fName,fName_metadata)
#sadly, these two files have different number of rows. We have both samples with no metadata and metadata with no samples. First find the places that do not match and then remove the rows with no metaData as they will not be helpful for my purposes; sadly this involves more steps #variables to merge are here:
#mData$variable #use this to match (ends with CSV)
#metaData$Sample #nothing after sample name
#metaData$coreMSname #nothing after sample name
#easiest is probably to add csv to each metaData row
for (idx in 1:dim(metaData)[1]) {
one <- metaData$Sample[idx]
metaData$nameWithCSV[idx] <- paste0(one,".csv")
rm(one)
}
rm(idx)
keepIdx <- data.frame()
#probably a better way to do this, but I need the index
for (idx in 1:dim(metaData)[1]) {
kI <- which(metaData$nameWithCSV[idx] == mData$variable)
keepIdx <- append(keepIdx,kI)
rm(kI)
}
rm(idx)
#only keep the rows in metaData with actual data
#check this later - on a plane and possibly not fully thinking right
useIdx <- as.numeric(keepIdx)
metaData <- metaData[useIdx,]
mData <- mData[useIdx,]
rm(keepIdx,useIdx)
#check again that mData and metaData match
keepIdx <- data.frame()
for (idx in 1:dim(mData)[1]) {
kI <- which(mData$variable[idx] == metaData$nameWithCSV)
keepIdx <- append(keepIdx,kI)
rm(kI)
}
rm(idx)
#only keep the rows in mData with matching metaData data
useIdx <- as.numeric(keepIdx)
mData <- mData[useIdx,]
metaData <- metaData[useIdx,]
rm(keepIdx,useIdx)
#now do an NMS on the derived variables in the metadata file
idxRows <- c(1:dim(mData)[1]) #how many rows...
cols <- colnames(mData)
idxCol <- cols
#idxCol =c('C_pool','N_value')
#need unlist because the first bit produces a list
useData <- as.numeric(unlist(mData[idxRows,idxCol]))
tData <- mData[idxRows,idxCol]
useData <- setDT(tData,keep.rownames=TRUE)
rm(tData)
#Have some options for the distance matrix:
#data pre-processing; #requires the vegan package
dataRel = decostand(x=useData,method = "pa",na.rm=TRUE)
useDistance = "bray" #vegan will want this again later
calcDistMat = vegdist(dataRel,method = useDistance,na.rm=TRUE)
sampleTree = flashClust(calcDistMat,method = "ward")
par(cex=1.5)
par(mar = c(2,2,2,3))
plot(as.dendrogram(sampleTree),horiz=T)
# dig into the past and setup NMS code here in R (ask Yuting for the variability on each axis)
#(https://rpubs.com/CPEL/NMDS)
# Running NMDS in vegan (metaMDS); just testing path for now, will need to change the settings
output_NMS <-
metaMDS(calcDistMat,
distance = useDistance,
k = 2,
maxit = 2,
trymax = 2,
wascores = TRUE)
# Plotting points in ordination space
plot(output_NMS, "sites")   # Produces distance
#this will stress my R, but I want to make NMS plots with color-coded points for variables...start there, eventually may want to do this with scaled variables. Easiest to start will be 'type'
#this will involve ggplot
# Alternatively we can fully specify the plot in each layer. This
# is not useful here, but can be more clear when working with complex
# mult-dataset graphics
df <- as.data.frame(output_NMS$points)
oneVal <- metaData$type
help("ggplot")
ggplot(data = df)
df
head(df)
help("aes")
ggplot(data = df,aes(df))
ggplot(data = df,aes(df$MSD1))
geom_point(data = df, aes(x=df$MSD1,y=df$MDS2))
ggplot(data = df,aes(x=df$MSD1,y=df$MDS2) +
)
ggplot(data = df,aes(x=df$MSD1,y=df$MDS2) +
geom_point(data = df, aes(x=df$MSD1,y=df$MDS2)) +
geom_point(data =df, aes(x=df$MSD1,y=df$MDS2), color = 'blue'))
ggplot(data = df,aes(x=df$MSD1,y=df$MDS2) +
geom_point(data = df, aes(x=df$MSD1,y=df$MDS2)))
aes(x=df$MSD1,y=df$MDS2)
help(ggplot)
ggplot(data = df,aes(x=df$MSD1,y=df$MDS2) +
geom_point())
ggplot(data = df)
df
ggplot(df) +
geom_point(aes(x = df$MDS1))
ggplot(df,aes(x=df$MDS1,y=df$MDS2) +
geom_point())
geom_point(df)
head(df)
ggplot(df,aes(MDS1,MDS2))
ggplot(df,aes(MDS1,MDS2)+
geom_point)
p <- ggplot(df,aes(MDS1,MDS2))
p <- ggplot(df,aes(MDS1,MDS2))
p + geom_point())
p <- ggplot(df,aes(MDS1,MDS2))
p + geom_point()
#now, try again, can I do this and color the points by ecosystem ('type')
p <- ggplot(df,aes(MDS1,MDS2))
p + geom_point(aes(colour = factor(metaData$type)))
quit()
